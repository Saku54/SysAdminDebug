<#
.SYNOPSIS
    Outil tout-en-un de diagnostic pour machine virtuelle (VM) sous Windows.

.DESCRIPTION
    Ce script PowerShell avec interface graphique (WinForms) permet de r√©aliser rapidement
    plusieurs tests de sant√© syst√®me sur une VM d'h√©bergement client :
    - V√©rification de l'espace disque
    - √âtat des services critiques
    - Utilisation CPU et RAM
    - Connectivit√© r√©seau via ping
    - √âtat de l'antivirus Windows Defender
    - V√©rification des mises √† jour Windows en attente
    - Analyse des derniers logs syst√®me (erreurs)

    L‚Äôutilisateur peut s√©lectionner les tests √† effectuer via une checklist,
    lancer l‚Äôaudit, et consulter les r√©sultats dans une fen√™tre d√©di√©e.

.AUTHOR
    GGO - Administrateur Syst√®me

.VERSION
    1.0 - 2025-05-28 - Version initiale

.NOTES
    - N√©cessite PowerShell ex√©cut√© avec droits administrateur pour certains tests.
    - Utilise les composants COM Microsoft.Update.Session pour r√©cup√©rer les mises √† jour.
    - Destin√© √† faciliter le diagnostic rapide sur les VM Windows h√©berg√©es.

.EXAMPLE
    .\Outil-Diagnostic-VM.ps1
#>

Add-Type -AssemblyName System.Windows.Forms
Add-Type -AssemblyName System.Drawing

# Dictionnaire des tests Disponibles.
$TestsDisponibles = @(
    "Espace disque",
    "Utilisation CPU / RAM",
    "Connectivit√© r√©seau",
    "Test port et firewall",
    "Mises √† jour Windows",
    "WSUS",
    "Logs syst√®mes",
    "Recherche utilisateur AD"
)

###############################################
### Fonction de Gestion du Formulaire #########
###############################################

function Show-AdvancedFeaturesForm {

    $formAdv = New-Object System.Windows.Forms.Form
    $formAdv.Text = "Fonctionnalit√©s avanc√©es - Diagnostic approfondi"
    $formAdv.Size = New-Object System.Drawing.Size(1000,800)
    $formAdv.StartPosition = "CenterScreen"

    $labelAdv = New-Object System.Windows.Forms.Label
    $labelAdv.Text = "S√©lectionnez les tests avanc√©s √† r√©aliser :"
    $labelAdv.Location = New-Object System.Drawing.Point(20,20)
    $labelAdv.AutoSize = $true
    $formAdv.Controls.Add($labelAdv)

   # D√©finition fiable des tests avec cl√©s simples
    $testsAdv = [ordered]@{
    "sfc_dism"         = "Int√©grit√© syst√®me (SFC / DISM)"
    "boot_perf"        = "Temps d√©marrage services critiques"
    "dns_latency"      = "Latence DNS / R√©solution noms"
    "drivers"          = "√âtat des pilotes"
    "ntp"              = "Synchronisation NTP"
    "security_basics"  = "Validation des param√®tres de s√©curit√© de base"
    "startup_programs" = "Recherche des programmes au d√©marrage"
    "domain_controller"     = "Connexion au contr√¥leur de domaine (NLTest / DCDiag lite)"
    "recent_boot"           = "Temps de d√©marrage r√©cent (EventLog 6005/6006 ou Uptime)"
    "certificates_check" =  "Verifier les certificats"
    "temp_files_check" = "V√©rifie les fichiers TEMP + orphelins sur la lettre choisie"
    "device_errors"         = "Liste des p√©riph√©riques en erreur (gestionnaire de p√©riph√©riques)"
    "failed_scheduled_tasks"= "V√©rification des t√¢ches planifi√©es en √©chec"
    "bitlocker_status"      = "√âtat de BitLocker (si applicable)"
    "resource_usage"        = "Ressources bloquantes ou processus anormaux (CPU / RAM)"
    "disk_usage_top"        = "Utilisation disque par fichiers lourds (top 10)"
    "disk_permission_issues" = "Probl√®mes de droits sur les repertoires"
    
}

$checkboxesAdv = @{}
$yAdv = 50
$textboxesAdv = @{}

foreach ($key in $testsAdv.Keys) {
    $cb = New-Object System.Windows.Forms.CheckBox
    $cb.Text = $testsAdv[$key]
    $cb.Location = New-Object System.Drawing.Point(40, $yAdv)
    $cb.AutoSize = $true
    $formAdv.Controls.Add($cb)  # <-- On ajoute qu'une fois ici

    $checkboxesAdv[$key] = $cb 

    if ($key -eq "dns_latency") {
        # Ne PAS ajouter $cb une seconde fois ici (ligne supprim√©e)

        $cb.Width = 200

        $tb = New-Object System.Windows.Forms.TextBox
        $tb.Size = New-Object System.Drawing.Size(200, 20)
        $tb.Location = New-Object System.Drawing.Point(($cb.Location.X + $cb.Width + 10), $cb.Location.Y)
        $tb.Text = "www.google.com"
        $tb.Visible = $false
        $formAdv.Controls.Add($tb)
        $textboxesAdv[$key] = $tb

        # Important: Capturer les variables pour l'event handler
        $cb.Add_CheckedChanged({
            param($sender, $args)
            # Debug
            Write-Host "Checkbox dns_latency checked = $($sender.Checked)"
            $tb.Visible = $sender.Checked
        })
    }

    $yAdv += 30
}

    # Menu d√©roulant pour s√©lectionner le disque √† analyser
    $labelDisk = New-Object System.Windows.Forms.Label
    $labelDisk.Text = "Disque √† analyser"
    $labelDisk.Location = New-Object System.Drawing.Point(40, $yAdv)
    $formAdv.Controls.Add($labelDisk)

    $comboDisk = New-Object System.Windows.Forms.ComboBox
    $comboDisk.Location = New-Object System.Drawing.Point(160, ($yAdv - 3))
    $comboDisk.Size = New-Object System.Drawing.Size(240, 20)
    $comboDisk.DropDownStyle = 'DropDownList'

    # Pr√©parer la liste des disques fixes avec taille libre / totale
$fixedDrives = [System.IO.DriveInfo]::GetDrives() | Where-Object { $_.DriveType -eq 'Fixed' }

foreach ($drive in $fixedDrives) {
    $freeGB = [math]::Round($drive.AvailableFreeSpace / 1GB, 2)
    $totalGB = [math]::Round($drive.TotalSize / 1GB, 2)
    $displayText = "$($drive.Name) - Libre : $freeGB GB / Total : $totalGB GB"
    $comboDisk.Items.Add($displayText)
}

# S√©lectionner le premier disque par d√©faut
$comboDisk.SelectedIndex = 0

$formAdv.Controls.Add($comboDisk)

$yAdv += 30

    # Zone r√©sultats
    $resultsBoxAdv = New-Object System.Windows.Forms.TextBox
    $resultsBoxAdv.Multiline = $true
    $resultsBoxAdv.ScrollBars = "Vertical"
    $resultsBoxAdv.Location = New-Object System.Drawing.Point(500, 50)  # √Ä droite des checkbox
    $resultsBoxAdv.Size = New-Object System.Drawing.Size(420, 400)      # Haute mais pas jusqu'au bouton
    $resultsBoxAdv.Font = New-Object System.Drawing.Font("Consolas", 10)
    $formAdv.Controls.Add($resultsBoxAdv)

    # Calcul de la position Y apr√®s les derni√®res checkbox
    $baseY = $yAdv + 10  # $yAdv vaut ici 470, donc baseY = 480

    # Bouton lancer tests avanc√©s
    $buttonRunAdv = New-Object System.Windows.Forms.Button
    $buttonRunAdv.Text = "Lancer tests avanc√©s"
    $buttonRunAdv.Location = New-Object System.Drawing.Point(40, $baseY)
    $buttonRunAdv.Size = New-Object System.Drawing.Size(150, 30)
    $formAdv.Controls.Add($buttonRunAdv)

    # ProgressBar en dessous du bouton (30 + 10 px plus bas)
    $progressBarAdv = New-Object System.Windows.Forms.ProgressBar
    $progressBarAdv.Size = New-Object System.Drawing.Size(310, 20)
    $progressBarAdv.Location = New-Object System.Drawing.Point(40, ($baseY + 40))
    $progressBarAdv.Minimum = 0
    $progressBarAdv.Maximum = 100
    $progressBarAdv.Value = 0
    $formAdv.Controls.Add($progressBarAdv)

    # Fonction interne d'ex√©cution des tests avanc√©s
    function Invoke-AdvancedTest {
    param(
        [string]$testKey,
        [string]$driveLetter = $null,
        [string]$dnsHost = $null   # <-- nouveau param√®tre pour dns_latency
    )

    switch ($testKey) {
        "certificates_check" {
    $out = "üîê V√©rification des certificats num√©riques install√©s...`r`n`r`n"
    try {
        $stores = @("Cert:\LocalMachine\My", "Cert:\CurrentUser\My")
        foreach ($store in $stores) {
            $out += "Magasin : $store`r`n"
            $certs = Get-ChildItem -Path $store -ErrorAction SilentlyContinue
            if ($certs) {
                foreach ($cert in $certs) {
                    $subject = $cert.Subject
                    $issuer = $cert.Issuer
                    $expiry = $cert.NotAfter
                    $now = Get-Date
                    $validity = if ($expiry -gt $now) { "Valide" } else { "Expir√©" }
                    $daysLeft = ($expiry - $now).Days
                    $out += " - Sujet : $subject`r`n   √âmetteur : $issuer`r`n   Expire le : $expiry ($validity, Jours restants : $daysLeft)`r`n`r`n"
                }
            } else {
                $out += "Aucun certificat trouv√© dans ce magasin.`r`n"
            }
        }
    }
    catch {
        $out += "‚ùå Erreur lors de la r√©cup√©ration des certificats : $_`r`n"
    }
    return $out
}
"temp_files_check" {
    if (-not $driveLetter) {
        return "‚ùå Aucun disque sp√©cifi√© pour la recherche de fichiers temporaires."
    }

    $out = "üóÇÔ∏è Recherche de fichiers temporaires volumineux (>100MB) sur $driveLetter ...`r`n`r`n"
    try {
        $tempPaths = @(
            Join-Path $driveLetter "Windows\Temp"
        )

        # Pour le chemin avec wildcard, on va le g√©rer √† part, car Join-Path ne supporte pas le '*'
        $userTempPathPattern = Join-Path $driveLetter "Users"
        $userTempPaths = Get-ChildItem -Path $userTempPathPattern -Directory -ErrorAction SilentlyContinue | ForEach-Object {
            Join-Path $_.FullName "AppData\Local\Temp"
        }
        $tempPaths += $userTempPaths

        # Ajouter ProgramData\Temp aussi
        $tempPaths += Join-Path $driveLetter "ProgramData\Temp"

        $bigTempFiles = @()

        foreach ($path in $tempPaths) {
            if (Test-Path $path) {
                $files = Get-ChildItem -Path $path -File -Recurse -ErrorAction SilentlyContinue | Where-Object { $_.Length -gt 100MB }
                $bigTempFiles += $files
            }
        }

        if ($bigTempFiles.Count -eq 0) {
            $out += "‚úÖ Aucun fichier temporaire volumineux d√©tect√©.`r`n"
        } else {
            $topFiles = $bigTempFiles | Sort-Object Length -Descending | Select-Object -First 20
            $counter = 1
            foreach ($file in $topFiles) {
                $sizeMB = [math]::Round($file.Length / 1MB, 2)
                $out += " $counter. $($file.FullName) ‚Äî $sizeMB MB`r`n"
                $counter++
            }
        }
    }
    catch {
        $out += "‚ùå Erreur lors de la recherche de fichiers temporaires : $_`r`n"
    }
    return $out
}

        "sfc_dism" {
            $out = "Lancement de sfc /scannow (cela peut prendre plusieurs minutes)...`r`n"
            try {
                $proc = Start-Process -FilePath "sfc.exe" -ArgumentList "/scannow" -NoNewWindow -Wait -PassThru
                $out += "sfc /scannow termin√© avec le code de sortie : $($proc.ExitCode)`r`n"
                $dism = Start-Process -FilePath "dism.exe" -ArgumentList "/Online /Cleanup-Image /CheckHealth" -NoNewWindow -Wait -PassThru
                $out += "DISM /CheckHealth termin√© avec le code de sortie : $($dism.ExitCode)`r`n"
            } catch {
                $out += "Erreur lors de l'ex√©cution de sfc ou DISM : $_"
            }
            return $out
        }
        "boot_perf" {
            $out = "Analyse du temps de d√©marrage des services critiques...`r`n"
            # Exemple simple : r√©cup√©rer les √©v√©nements 6005 et 6006 dans le journal syst√®me
            try {
                $evt6005 = Get-WinEvent -FilterHashtable @{LogName='System'; Id=6005} -MaxEvents 1 | Select-Object -ExpandProperty TimeCreated
                $evt6006 = Get-WinEvent -FilterHashtable @{LogName='System'; Id=6006} -MaxEvents 1 | Select-Object -ExpandProperty TimeCreated
                $out += "Dernier √©v√©nement 6005 (d√©marrage du service journal): $evt6005`r`n"
                $out += "Dernier √©v√©nement 6006 (arr√™t du service journal) : $evt6006`r`n"
            } catch {
                $out += "Erreur lors de la lecture des √©v√©nements syst√®me : $_"
            }
            return $out
        }
        "dns_latency" {
            $domainToResolve = if ($dnsHost) { $dnsHost } else { "www.google.com" }
            $out = "Test de latence DNS (r√©solution de $domainToResolve)...`r`n"
            try {
                $start = Get-Date
                Resolve-DnsName $domainToResolve | Out-Null
                $duration = (Get-Date) - $start
                $out += "R√©solution DNS termin√©e en $([math]::Round($duration.TotalMilliseconds,2)) ms.`r`n"
            } catch {
                $out += "Erreur lors de la r√©solution DNS : $_"
            }
            return $out
        }
        "drivers" {
            $out = "V√©rification de l‚Äô√©tat des pilotes...`r`n"
            try {
                $driversWithErrors = Get-WmiObject Win32_PnPEntity | Where-Object { $_.ConfigManagerErrorCode -ne 0 }
                if ($driversWithErrors) {
                    foreach ($drv in $driversWithErrors) {
                        $out += "Pilote en erreur : $($drv.Name) - Code erreur : $($drv.ConfigManagerErrorCode)`r`n"
                    }
                } else {
                    $out += "Aucun pilote avec erreur d√©tect√©.`r`n"
                }
            } catch {
                $out += "Erreur lors de la v√©rification des pilotes : $_"
            }
            return $out
        }
        "disk_latency" {
            $out = "Analyse d'utilisation disque (top 10 fichiers les plus lourds)...`r`n"
            try {
                $topFiles = Get-ChildItem -Path C:\ -Recurse -ErrorAction SilentlyContinue | 
                    Where-Object { -not $_.PSIsContainer } | 
                    Sort-Object Length -Descending | Select-Object -First 10 FullName, Length
                foreach ($file in $topFiles) {
                    $sizeMB = [math]::Round($file.Length / 1MB, 2)
                    $out += "$($file.FullName) - $sizeMB MB`r`n"
                }
            } catch {
                $out += "Erreur lors de l'analyse disque : $_"
            }
            return $out
        }
        "ntp" {
            $out = "V√©rification de la synchronisation NTP...`r`n"
            try {
                $w32Time = Get-Service w32time -ErrorAction Stop
                $out += "Service Windows Time est : $($w32Time.Status)`r`n"
                $ntpStatus = w32tm /query /status 2>&1
                $out += $ntpStatus -join "`r`n"
            } catch {
                $out += "Erreur lors de la v√©rification NTP : $_"
            }
            return $out
        }
        "security_basics" {
            $out = "Contr√¥le des param√®tres de s√©curit√© de base...`r`n"
            try {
                # Comptes admin d√©sactiv√©s
                $disabledAdmins = Get-LocalGroupMember -Group "Administrateurs" | Where-Object {
                    $user = $_.Name
                    $acc = Get-LocalUser -Name $user -ErrorAction SilentlyContinue
                    $acc -and $acc.Enabled -eq $false
                }
                if ($disabledAdmins) {
                    $out += "Comptes admin d√©sactiv√©s : " + ($disabledAdmins.Name -join ", ") + "`r`n"
                } else {
                    $out += "Aucun compte admin d√©sactiv√© d√©tect√©.`r`n"
                }
                # UAC activ√© ?
                $uacValue = Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System" -Name EnableLUA -ErrorAction SilentlyContinue
                if ($uacValue.EnableLUA -eq 1) {
                    $out += "UAC est activ√©.`r`n"
                } else {
                    $out += "UAC est d√©sactiv√© !`r`n"
                }
            } catch {
                $out += "Erreur lors de la v√©rification des param√®tres de s√©curit√© : $_"
            }
            return $out
        }
        "startup_programs" {
            $out = "Recherche des programmes au d√©marrage...`r`n"
            try {
                $startupItems = Get-CimInstance -ClassName Win32_StartupCommand
                foreach ($item in $startupItems) {
                    $out += "Nom: $($item.Name)`r`n"
                }
            } catch {
                $out += "Erreur lors de la recherche des programmes au d√©marrage : $_"
            }
            return $out
        }
        "domain_controller" {
            $out = "V√©rification connexion au contr√¥leur de domaine...`r`n"
            try {
                $domain = (Get-WmiObject Win32_ComputerSystem).Domain
                $out += "Domaine de la machine : $domain`r`n"
                $nltest = nltest /dsgetdc:$domain 2>&1
                $out += $nltest -join "`r`n"
            } catch {
                $out += "Erreur lors de la v√©rification du contr√¥leur de domaine : $_"
            }
            return $out
        }
        "recent_boot" {
            $out = "Consultation du temps de d√©marrage r√©cent...`r`n"
            try {
                $lastBoot = (Get-CimInstance Win32_OperatingSystem).LastBootUpTime
                $uptime = (Get-Date) - $lastBoot
                $out += "Dernier d√©marrage : $lastBoot`r`n"
                $out += "Uptime : $([math]::Round($uptime.TotalHours,2)) heures`r`n"
            } catch {
                $out += "Erreur lors de la lecture du temps de d√©marrage : $_"
            }
            return $out
        }
        "device_errors" {
            $out = "Liste des p√©riph√©riques en erreur...`r`n"
            try {
                $devicesErr = Get-WmiObject Win32_PnPEntity | Where-Object { $_.ConfigManagerErrorCode -ne 0 }
                if ($devicesErr) {
                    foreach ($dev in $devicesErr) {
                        $out += "P√©riph√©rique : $($dev.Name), Code erreur : $($dev.ConfigManagerErrorCode)`r`n"
                    }
                } else {
                    $out += "Aucun p√©riph√©rique en erreur d√©tect√©.`r`n"
                }
            } catch {
                $out += "Erreur lors de la r√©cup√©ration des p√©riph√©riques : $_"
            }
            return $out
        }
        "failed_scheduled_tasks" {
            $out = "V√©rification des t√¢ches planifi√©es d√©sactiv√©es ou en √©chec...`r`n"
            try {
                $tasks = Get-ScheduledTask | Where-Object { $_.State -eq 'Disabled' -or $_.State -eq 'Failed' }
                if ($tasks) {
                    foreach ($t in $tasks) {
                        $out += "T√¢che: $($t.TaskName), √âtat: $($t.State)`r`n"
                    }
                } else {
                    $out += "Aucune t√¢che planifi√©e d√©sactiv√©e ou en √©chec.`r`n"
                }
            } catch {
                $out += "Erreur lors de la r√©cup√©ration des t√¢ches planifi√©es : $_"
            }
            return $out
        }

        "bitlocker_status" {
            $out = "√âtat de BitLocker...`r`n"
            try {
                $volumes = Get-BitLockerVolume
                foreach ($vol in $volumes) {
                    $out += "Volume: $($vol.MountPoint), Statut: $($vol.VolumeStatus)`r`n"
                }
            } catch {
                $out += "Erreur lors de la r√©cup√©ration de l'√©tat BitLocker : $_"
            }
            return $out
        }

        "resource_usage" {
    $out = "‚öôÔ∏è Ressources bloquantes / processus gourmands...`r`n"
    try {
        $topCPU = Get-Process | Where-Object { $_.CPU -ne $null } |
                  Sort-Object CPU -Descending | Select-Object -First 5 -Property Id, ProcessName, CPU, WorkingSet

        foreach ($proc in $topCPU) {
            $cpu = [math]::Round($proc.CPU, 2)
            $memMB = [math]::Round($proc.WorkingSet / 1MB, 2)
            $out += " - $($proc.ProcessName) (PID: $($proc.Id)) CPU: $cpu sec, RAM: $memMB MB`r`n"
        }
    }
    catch {
        $out += "Erreur lors de la r√©cup√©ration des processus gourmands : $_`r`n"
    }
    return $out
}

 "disk_usage_top" {
    if (-not $driveLetter) {
        return "‚ùå Aucun disque sp√©cifi√© pour le test d'utilisation disque."
    }

    $out = "üìÅ Top 10 des fichiers les plus lourds sur $driveLetter :`r`n`r`n"
    $files = @()

    # Fonction r√©cursive s√©curis√©e pour r√©cup√©rer fichiers avec gestion d'erreurs
    function Get-FilesSafely($path) {
        $collectedFiles = @()
        try {
            # R√©cup√©rer les fichiers dans ce dossier
            $collectedFiles += Get-ChildItem -Path $path -File -ErrorAction Stop

            # R√©cup√©rer les sous-dossiers pour descendre r√©cursivement
            $subdirs = Get-ChildItem -Path $path -Directory -ErrorAction Stop
            foreach ($subdir in $subdirs) {
                $collectedFiles += Get-FilesSafely -path $subdir.FullName
            }
        }
        catch {
            # Ignorer les erreurs d'acc√®s et continuer
        }
        return $collectedFiles
    }

    try {
        if ($driveLetter -eq "C:\") {
            $safeFolders = @("C:\Users", "C:\ProgramData", "C:\Temp")
            foreach ($folder in $safeFolders) {
                if (Test-Path $folder) {
                    $files += Get-FilesSafely -path $folder
                }
            }
        }
        else {
            if (Test-Path $driveLetter) {
                $files += Get-FilesSafely -path $driveLetter
            }
            else {
                return "‚ö†Ô∏è Le disque $driveLetter n'existe pas ou n'est pas accessible.`r`n"
            }
        }

        if ($files.Count -eq 0) {
            $out += "‚ÑπÔ∏è Aucun fichier trouv√© sur le disque $driveLetter.`r`n"
        }
        else {
            $topFiles = $files | Sort-Object Length -Descending | Select-Object -First 10
            $counter = 1
            foreach ($file in $topFiles) {
                $sizeMB = [math]::Round($file.Length / 1MB, 2)
                $out += " $counter. $($file.FullName) ‚Äî $sizeMB MB`r`n"
                $counter++
            }
        }
    }
    catch {
        $out += "‚ùå Erreur lors de la r√©cup√©ration des fichiers lourds : $_`r`n"
    }

    return $out
}
"disk_permission_issues" {
    param (
        [string]$driveLetter
    )

    if (-not $driveLetter) {
        return "‚ùå Aucun disque sp√©cifi√© pour le test des permissions de cr√©ation."
    }

    $out = "üîç V√©rification des dossiers o√π la cr√©ation n√©cessite une √©l√©vation sur $driveLetter ...`r`n`r`n"

    try {
        if (-not (Test-Path $driveLetter)) {
            return "‚ö†Ô∏è Le disque $driveLetter n'existe pas ou n'est pas accessible.`r`n"
        }

        # Lister les dossiers √† la racine du disque
        $rootFolders = Get-ChildItem -Path $driveLetter -Directory -ErrorAction Stop
        $protectedFolders = @()

        foreach ($folder in $rootFolders) {
            $testDirName = "TestCreateDir_$([guid]::NewGuid().ToString())"
            $testDirPath = Join-Path -Path $folder.FullName -ChildPath $testDirName

            try {
                # Tenter de cr√©er un dossier test
                New-Item -Path $testDirPath -ItemType Directory -ErrorAction Stop | Out-Null

                # Si cr√©ation r√©ussie, supprimer le dossier test
                Remove-Item -Path $testDirPath -Force -Recurse -ErrorAction SilentlyContinue
            }
            catch {
                # Si erreur (probablement acc√®s refus√©), ajouter dossier √† la liste
                $protectedFolders += $folder.FullName
            }
        }

        if ($protectedFolders.Count -eq 0) {
            $out += "‚úÖ Aucun dossier ne n√©cessite d'√©l√©vation pour cr√©er un dossier √† la racine de $driveLetter.`r`n"
        }
        else {
            $out += "‚ö†Ô∏è Dossiers n√©cessitant une √©l√©vation pour cr√©er un dossier :`r`n"
            foreach ($p in $protectedFolders) {
                $out += " - $p`r`n"
            }
        }
    }
    catch {
        $out += "‚ùå Erreur lors du test de cr√©ation des dossiers : $_`r`n"
    }

    return $out
}
        default {
            return "Test inconnu : $testKey"
        }
    }
}

    # Action bouton lancer tests avanc√©s
    $buttonRunAdv.Add_Click({
    $resultsBoxAdv.Clear()
    $progressBarAdv.Value = 0
    
    # Debug affichage checkboxes coch√©es
    foreach ($key in $checkboxesAdv.Keys) {
        Write-Host "Checkbox $key Checked = $($checkboxesAdv[$key].Checked)"
    }

    $testsChecked = $checkboxesAdv.GetEnumerator() | Where-Object { $_.Value.Checked } | ForEach-Object { $_.Key }
    $total = $testsChecked.Count

    if ($total -eq 0) {
        $resultsBoxAdv.AppendText("Veuillez s√©lectionner au moins un test avanc√©.`r`n")
        return
    }

    $i = 0
    foreach ($testKey in $testsChecked) {
        $label = $testsAdv[$testKey]
        $resultsBoxAdv.AppendText("[$label] Test en cours...`r`n")

        switch ($testKey) {
            "dns_latency" {
                $dnsHost = $null
                if ($textboxesAdv.ContainsKey($testKey)) {
                    $dnsHost = $textboxesAdv[$testKey].Text.Trim()
                }
                if ([string]::IsNullOrWhiteSpace($dnsHost)) {
                    [System.Windows.Forms.MessageBox]::Show("Veuillez remplir le champ Domaine pour le test DNS.", "Erreur", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Warning)
                    return
                }
                $res = Invoke-AdvancedTest -testKey $testKey -dnsHost $dnsHost
            }
            "disk_usage_top" {
        # R√©cup√©rer la lettre du disque s√©lectionn√©e dans la combobox
        $driveLetter = $comboDisk.SelectedItem
        if (-not $driveLetter) {
            [System.Windows.Forms.MessageBox]::Show("Veuillez s√©lectionner un disque pour le test d'utilisation disque.", "Erreur", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Warning)
            return
        }
        $res = Invoke-AdvancedTest -testKey $testKey -driveLetter $driveLetter
    }
            "disk_permission_issues" {
            $driveLetter = $comboDisk.SelectedItem
            if (-not $driveLetter) {
                [System.Windows.Forms.MessageBox]::Show("Veuillez s√©lectionner un disque pour le test des permissions de cr√©ation.", "Erreur", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Warning)
                return
            }
            $res = Invoke-AdvancedTest -testKey $testKey -driveLetter $driveLetter
        }
        "temp_files_check" {
            $driveLetter = $comboDisk.SelectedItem
            if (-not $driveLetter) {
                [System.Windows.Forms.MessageBox]::Show("Veuillez s√©lectionner un disque pour la recherche de fichiers temporaires.", "Erreur", [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Warning)
                return
            }
            $res = Invoke-AdvancedTest -testKey $testKey -driveLetter $driveLetter
        }
        default {
            $res = Invoke-AdvancedTest -testKey $testKey
        }
    }
         
        $resultsBoxAdv.AppendText($res + "`r`n")
        $resultsBoxAdv.AppendText("[$label] Test termin√©.`r`n`r`n")

        $i++
        $progressBarAdv.Value = [math]::Min(100, [math]::Round(($i / $total) * 100))
        $formAdv.Refresh()
        [System.Windows.Forms.Application]::DoEvents()
    }

    $progressBarAdv.Value = 100
})

    $formAdv.ShowDialog()
}


function Show-VMHealthForm {
    $form = New-Object System.Windows.Forms.Form
    $form.Text = "Diagnostic VM - Outil tout-en-un"
    $form.Size = New-Object System.Drawing.Size(600,750)
    $form.StartPosition = "CenterScreen"

    $label = New-Object System.Windows.Forms.Label
    $label.Text = "S√©lectionnez les tests √† effectuer :"
    $label.Location = New-Object System.Drawing.Point(20,20)
    $label.AutoSize = $true
    $form.Controls.Add($label)

    $checkboxes = @{}
    $y = 50

    # Cr√©ation des checkboxes et champs sp√©cifiques
    foreach ($test in $TestsDisponibles) {
        $cb = New-Object System.Windows.Forms.CheckBox
        $cb.Text = $test
        $cb.Location = New-Object System.Drawing.Point(40, $y)
        $cb.AutoSize = $true
        $form.Controls.Add($cb)
        $checkboxes[$test] = $cb

        # TextBox IP pour Connectivit√© r√©seau - initialement cach√©s
        if ($test -eq "Connectivit√© r√©seau") {
            $txtIP = New-Object System.Windows.Forms.TextBox
            $txtIP.Name = "txtIP"
            $txtIP.Size = New-Object System.Drawing.Size(120, 20)
            $txtIP.Location = New-Object System.Drawing.Point(200, $y)
            $txtIP.Text = "127.0.0.1"
            $txtIP.Visible = $false
            $form.Controls.Add($txtIP)

            $lblIP = New-Object System.Windows.Forms.Label
            $lblIP.Text = "IP Destination"
            $lblIP.Location = New-Object System.Drawing.Point(330, ($y + 3))
            $lblIP.AutoSize = $true
            $lblIP.Visible = $false
            $form.Controls.Add($lblIP)
        }

        # TextBox Port pour Test port et firewall - initialement cach√©s
        if ($test -eq "Test port et firewall") {
            $txtPort = New-Object System.Windows.Forms.TextBox
            $txtPort.Name = "txtPort"
            $txtPort.Size = New-Object System.Drawing.Size(60, 20)
            $txtPort.Location = New-Object System.Drawing.Point(200, $y)
            $txtPort.Text = ""
            $txtPort.Visible = $false
            $form.Controls.Add($txtPort)

            $lblPort = New-Object System.Windows.Forms.Label
            $lblPort.Text = "Port √† tester"
            $lblPort.Location = New-Object System.Drawing.Point(270, ($y + 3))
            $lblPort.AutoSize = $true
            $lblPort.Visible = $false
            $form.Controls.Add($lblPort)
        }

        $y += 30
    }

    # Champs pour Recherche utilisateur AD (masqu√©s)
    $txtSam = New-Object System.Windows.Forms.TextBox
    $txtSam.Name = "txtSam"
    $txtSam.Size = New-Object System.Drawing.Size(150, 20)
    $txtSam.Location = New-Object System.Drawing.Point(250, (50 + (30 * ($TestsDisponibles.IndexOf("Recherche utilisateur AD")))))
    $txtSam.Visible = $false
    $form.Controls.Add($txtSam)

    $lblSam = New-Object System.Windows.Forms.Label
    $lblSam.Text = "sAMAccountName"
    $lblSam.Location = New-Object System.Drawing.Point(410, (53 + (30 * ($TestsDisponibles.IndexOf("Recherche utilisateur AD")))))
    $lblSam.AutoSize = $true
    $lblSam.Visible = $false
    $form.Controls.Add($lblSam)

    $txtDC = New-Object System.Windows.Forms.TextBox
    $txtDC.Name = "txtDC"
    $txtDC.Size = New-Object System.Drawing.Size(120, 20)
    $txtDC.Location = New-Object System.Drawing.Point(250, (50 + (30 * ($TestsDisponibles.IndexOf("Recherche utilisateur AD"))) + 30))
    $txtDC.Text = "DC=mondomaine,DC=local"
    $txtDC.Visible = $false
    $form.Controls.Add($txtDC)

    $lblDC = New-Object System.Windows.Forms.Label
    $lblDC.Text = "Base de recherche (DC)"
    $lblDC.Location = New-Object System.Drawing.Point(380, (83 + (30 * ($TestsDisponibles.IndexOf("Recherche utilisateur AD")))))
    $lblDC.AutoSize = $true
    $lblDC.Visible = $false
    $form.Controls.Add($lblDC)

    # Bouton Rechercher utilisateur AD
    $btnSearchUser = New-Object System.Windows.Forms.Button
    $btnSearchUser.Text = "Rechercher utilisateur"
    $btnSearchUser.Location = New-Object System.Drawing.Point(250, (50 + (30 * ($TestsDisponibles.IndexOf("Recherche utilisateur AD"))) + 60))
    $btnSearchUser.Size = New-Object System.Drawing.Size(150,25)
    $btnSearchUser.Visible = $false
    $form.Controls.Add($btnSearchUser)

    # Bouton Lancer l'audit
    $buttonRun = New-Object System.Windows.Forms.Button
    $buttonRun.Text = "Lancer l'audit"
    $buttonRun.Location = New-Object System.Drawing.Point(40, ($y + 10))
    $buttonRun.Size = New-Object System.Drawing.Size(100,30)
    $form.Controls.Add($buttonRun)

    # Bouton Fonctionnalit√©s avanc√©es
    $buttonAdvanced = New-Object System.Windows.Forms.Button
    $buttonAdvanced.Text = "Fonctionnalit√©s avanc√©es"
    $buttonAdvanced.Size = New-Object System.Drawing.Size(150, 30)
    $buttonAdvanced.Location = New-Object System.Drawing.Point(($form.ClientSize.Width - 170), 15)
    $buttonAdvanced.Anchor = [System.Windows.Forms.AnchorStyles]::Top -bor [System.Windows.Forms.AnchorStyles]::Right
    $form.Controls.Add($buttonAdvanced)

    # Action du bouton : ouvrir la fen√™tre avanc√©e
    $buttonAdvanced.Add_Click({
        Show-AdvancedFeaturesForm
    })

    # Bo√Æte de dialogue des R√©sultats
    $resultsBox = New-Object System.Windows.Forms.TextBox
    $resultsBox.Multiline = $true
    $resultsBox.ScrollBars = "Vertical"
    $resultsBox.Size = New-Object System.Drawing.Size(520,300)
    $resultsBox.Location = New-Object System.Drawing.Point(40, ($y + 60))
    $resultsBox.Font = New-Object System.Drawing.Font("Consolas",10)
    $form.Controls.Add($resultsBox)

    # --- Ajout de la barre de progression ---
    $progressBar = New-Object System.Windows.Forms.ProgressBar
    $progressBar.Size = New-Object System.Drawing.Size(520, 20)
    $progressBar.Location = New-Object System.Drawing.Point(40, ($y + 370))
    $progressBar.Minimum = 0
    $progressBar.Maximum = 100
    $progressBar.Value = 0
    $form.Controls.Add($progressBar)

    # Gestion dynamique de l'affichage des champs sAMAccountName et DC selon √©tat de la checkbox "Recherche utilisateur AD"
    $checkboxes["Recherche utilisateur AD"].Add_CheckedChanged({
        $checked = $checkboxes["Recherche utilisateur AD"].Checked
        $txtSam.Visible = $checked
        $lblSam.Visible = $checked
        $txtDC.Visible = $checked
        $lblDC.Visible = $checked
        $btnSearchUser.Visible = $checked
    })

    # Gestion dynamique pour Connectivit√© r√©seau (affiche/masque IP + label)
    $checkboxes["Connectivit√© r√©seau"].Add_CheckedChanged({
        $checked = $checkboxes["Connectivit√© r√©seau"].Checked
        $txtIP.Visible = $checked
        $lblIP.Visible = $checked
    })

    # Gestion dynamique pour Test port et firewall (affiche/masque Port + label)
    $checkboxes["Test port et firewall"].Add_CheckedChanged({
        $checked = $checkboxes["Test port et firewall"].Checked
        $txtPort.Visible = $checked
        $lblPort.Visible = $checked
    })

    # Action bouton Rechercher utilisateur AD
    $btnSearchUser.Add_Click({
        $samAccountName = $txtSam.Text
        $searchBase = $txtDC.Text
        $result = Invoke-Test "Recherche utilisateur AD" "" "" $samAccountName $searchBase
        $resultsBox.AppendText("[Recherche utilisateur AD] R√©sultat imm√©diat :" + [Environment]::NewLine)
        $resultsBox.AppendText($result + [Environment]::NewLine + [Environment]::NewLine)
    })

    # Action bouton Lancer l'audit avec mise √† jour dynamique de la ProgressBar
        $buttonRun.Add_Click({
        $resultsBox.Clear()
        $portValue = ""
        $ipValue = ""
        $samValue = ""
        $searchBase = ""

        foreach ($control in $form.Controls) {
            switch ($control.Name) {
                "txtPort" { $portValue = $control.Text }
                "txtIP"   { $ipValue = $control.Text }
                "txtSam"  { $samValue = $control.Text }
                "txtDC"   { $searchBase = $control.Text }
            }
        }

        $testsCoches = @()
        foreach ($kvp in $checkboxes.GetEnumerator()) {
            if ($kvp.Value.Checked) {
                $testsCoches += $kvp.Key
            }
        }

        # Initialiser la ProgressBar
        $progressBar.Value = 0
        $totalTests = $testsCoches.Count
        if ($totalTests -eq 0) {
            $resultsBox.AppendText("Veuillez s√©lectionner au moins un test." + [Environment]::NewLine)
            return
        }

        for ($i = 0; $i -lt $totalTests; $i++) {
            $testName = $testsCoches[$i]
            $resultsBox.AppendText("[$testName] Test en cours..." + [Environment]::NewLine)
            $result = Invoke-Test $testName $portValue $ipValue $samValue $searchBase
            $resultsBox.AppendText($result + [Environment]::NewLine + [Environment]::NewLine)
            $resultsBox.AppendText("[$testName] Test termin√©." + [Environment]::NewLine + [Environment]::NewLine)

            # Mise √† jour ProgressBar
            $progressBar.Value = [math]::Min(100, [math]::Round((($i + 1) / $totalTests) * 100))
            $form.Refresh()
        }
    })

    $form.ShowDialog()
}

###############################################
### Fonction de Gestion des tests #############
###############################################
function Invoke-Test($TestName, $PortToTest, $IPToTest, $SamAccount, $SearchBase) {
    # La fonction prend en param√®tre :
    # - $TestName : nom du test √† ex√©cuter
    # - $PortToTest : port √† analyser (si requis)
    # - $IPToTest : adresse IP √† tester (ping)
    # - $SamAccount : identifiant SAM pour la recherche AD
    # - $SearchBase : base LDAP de recherche pour AD

    switch ($TestName) {

        # ----- Test de l'espace disque -----
        "Espace disque" {
            # R√©cup√®re les disques locaux (type 3) via WMI
            $disks = Get-WmiObject Win32_LogicalDisk -Filter "DriveType=3"
            $out = ""
            foreach ($disk in $disks) {
                $freeGB = [math]::Round($disk.FreeSpace / 1GB,2)
                $totalGB = [math]::Round($disk.Size / 1GB,2)
                $out += "$($disk.DeviceID) : $freeGB GB libres sur $totalGB GB`r`n"
            }
            return $out
        }

        # ----- Test CPU / RAM -----
        "Utilisation CPU / RAM" {
            try {
                # Moyenne de la charge CPU et RAM libre
                $cpuLoad = Get-WmiObject -Class Win32_Processor | Measure-Object -Property LoadPercentage -Average | Select-Object -ExpandProperty Average
                $ram = Get-WmiObject Win32_OperatingSystem
                $ramFreeGB = [math]::Round($ram.FreePhysicalMemory / 1024 / 1024, 2)
                return "CPU : $cpuLoad % utilis√©`r`nRAM libre : $ramFreeGB GB"
            } catch {
                return "Impossible de r√©cup√©rer les stats CPU/RAM"
            }
        }

        # ----- Test de connectivit√© (ping IP) -----
        "Connectivit√© r√©seau" {
            # V√©rifie si l'adresse IP est valide
            if (-not [System.Net.IPAddress]::TryParse($IPToTest, [ref]$null)) {
                return "Erreur : IP invalide ou non renseign√©e. Exemple valide : 8.8.8.8"
            }

            # Ping 2 fois l‚Äôadresse IP (mode silencieux)
            $ping = Test-Connection -ComputerName $IPToTest -Count 2 -Quiet
            if ($ping) {
                return "Ping vers $IPToTest : OK"
            } else {
                return "Ping vers $IPToTest : √âchec"
            }
        }

        # ----- V√©rification des mises √† jour Windows disponibles -----
        "Mises √† jour Windows" {
            try {
                # Utilise les objets COM de Windows Update pour rechercher les MAJ non install√©es
                $session = New-Object -ComObject Microsoft.Update.Session
                $searcher = $session.CreateUpdateSearcher()
                $result = $searcher.Search("IsInstalled=0 and Type='Software'")
                if ($result.Updates.Count -eq 0) {
                    return "Aucune mise √† jour en attente."
                } else {
                    $out = "$($result.Updates.Count) mise(s) √† jour en attente :`r`n"
                    foreach ($update in $result.Updates) {
                        $out += "- $($update.Title)`r`n"
                    }
                    return $out
                }
            } catch {
                return "Impossible de r√©cup√©rer les mises √† jour (service d√©sactiv√© ou COM indisponible)."
            }
        }

        # ----- V√©rifie si WSUS est configur√© -----
        "WSUS" {
            $wsusKeyPath = "HKLM:\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate"
            $wsusServerValue = "WUServer"
            $wsusStatus = ""

            try {
                # V√©rifie l'existence de la cl√© WSUS et lit l'adresse configur√©e
                if (Test-Path $wsusKeyPath) {
                    $wsusServer = Get-ItemProperty -Path $wsusKeyPath -Name $wsusServerValue -ErrorAction SilentlyContinue
                    if ($wsusServer -and $wsusServer.$wsusServerValue) {
                        $wsusStatus = "Serveur WSUS configur√© : $($wsusServer.$wsusServerValue)"
                    } else {
                        $wsusStatus = "Aucun serveur WSUS configur√© dans la cl√© $wsusKeyPath"
                    }
                } else {
                    $wsusStatus = "Cl√© WSUS inexistante dans le registre."
                }
            } catch {
                $wsusStatus = "Erreur lors de la lecture du registre WSUS : $_"
            }

            return $wsusStatus
        }

        # ----- R√©cup√®re les 10 derni√®res erreurs syst√®me -----
        "Logs syst√®mes" {
            try {
                $errors = Get-EventLog -LogName System -EntryType Error -Newest 10
                return ($errors | ForEach-Object { "$($_.TimeGenerated) - $($_.Source): $($_.Message)" }) -join "`r`n"
            } catch {
                return "Impossible de r√©cup√©rer les logs syst√®mes."
            }
        }

        # ----- V√©rifie si un port TCP est ouvert (via netstat) -----
        "Test port et firewall" {
            # V√©rifie que le port est un entier valide
            if (-not [int]::TryParse($PortToTest, [ref]$null) -or $PortToTest -lt 1 -or $PortToTest -gt 65535) {
                return "Erreur : veuillez saisir un num√©ro de port valide entre 1 et 65535."
            }
            $port = [int]$PortToTest

            # Recherche le port dans la liste des connexions actives
            $netstatOutput = netstat -an | Select-String ":$port\s"
            if ($netstatOutput) {
                return "Port $port est ouvert et en √©coute."
            } else {
                return "Port $port ferm√© ou non en √©coute."
            }
        }

        # ----- Recherche utilisateur dans Active Directory -----
        "Recherche utilisateur AD" {
            # V√©rifie que les deux champs requis sont remplis
            if ([string]::IsNullOrEmpty($SamAccount) -or [string]::IsNullOrEmpty($SearchBase)) {
                return "Erreur : sAMAccountName et Base de recherche doivent √™tre renseign√©s."
            }
            try {
                # Charge le module Active Directory
                Import-Module ActiveDirectory -ErrorAction Stop

                # Recherche l'utilisateur correspondant au sAMAccountName
                $user = Get-ADUser -Filter "sAMAccountName -eq '$SamAccount'" -SearchBase $SearchBase -Properties *
                if ($null -eq $user) {
                    return "Utilisateur '$SamAccount' non trouv√© dans $SearchBase."
                } else {
                    return "Utilisateur trouv√© : `r`nNom : $($user.Name)`r`nCompte : $($user.sAMAccountName)`r`nEmail : $($user.EmailAddress)"
                }
            } catch {
                return "Erreur lors de la recherche AD : $_"
            }
        }

        # ----- Par d√©faut : test inconnu -----
        default {
            return "Test inconnu : $TestName"
        }
    }
}

# Lancer l‚Äôinterface
Show-VMHealthForm
